<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>çŸ¥è¯†å›¾è°± (æ‰‹ç»˜ç‰ˆ)</title>
	
	<style>
		:root {
			/* å¯çˆ±çš„æ‰‹ç»˜è°ƒè‰²æ¿ */
			--bg-paper: #fffdf5;
			--line-ink: #4a4a4a;
			--panel-bg: #ffffff;
			--shadow-sketch: 4px 4px 0px rgba(0,0,0,0.15);
			--font-hand: 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', Arial, sans-serif;
		}

		body {
			margin: 0;
			padding: 0;
			background-color: var(--bg-paper);
			background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
			background-size: 20px 20px; /* ç‚¹é˜µçº¸æ•ˆæœ */
			overflow: hidden;
			font-family: var(--font-hand);
			color: var(--line-ink);
		}
		
		#svg1 {
			width: 100%;
			height: 100%;
		}

		/* è¿çº¿æ ·å¼ï¼šæ·±ç°è‰²ï¼Œæ¨¡æ‹Ÿé“…ç¬” */
		.links line {
			stroke: var(--line-ink);
			stroke-opacity: 0.6;
			stroke-width: 2px;
			stroke-linecap: round;
			/* åº”ç”¨æ‰‹ç»˜æ»¤é•œ */
			filter: url(#sketch-line);
		}
		.links line.inactive {
			stroke-opacity: 0.1;
			stroke-dasharray: 4 4;
		}

		/* èŠ‚ç‚¹æ ·å¼ */
		.nodes circle {
			stroke: var(--line-ink);
			stroke-width: 2.5px;
			/* åº”ç”¨æ‰‹ç»˜æ»¤é•œï¼Œè®©åœ†åœˆä¸é‚£ä¹ˆåœ† */
			filter: url(#sketch-shape);
			cursor: pointer;
			transition: all 0.3s ease;
		}
		.nodes circle:hover {
			stroke-width: 4px;
			filter: drop-shadow(3px 3px 0px rgba(0,0,0,0.2)) url(#sketch-shape);
		}
		.nodes circle.inactive {
			opacity: 0.1;
		}

		/* æ–‡å­—æ ·å¼ */
		.texts text {
			font-family: var(--font-hand);
			fill: var(--line-ink);
			text-anchor: middle;
			pointer-events: none;
			font-weight: 700;
			/* æ–‡å­—æè¾¹ï¼Œä¿è¯åœ¨è¿çº¿ä¹‹ä¸Šæ¸…æ™°å¯è§ */
			paint-order: stroke;
			stroke: var(--bg-paper);
			stroke-width: 4px;
			stroke-linecap: round;
			stroke-linejoin: round;
		}
		.texts text.inactive {
			opacity: 0.1;
		}

		/* é¡¶éƒ¨ç§‘æŠ€æ„Ÿè£…é¥°æ¡ */
		.graph-header {
			position: fixed;
			top: 0px;
			left: 50%;
			transform: translateX(-50%);
			width: 100%;
			height: 120px;
			background: url('https://lms.cdut.edu.cn/static/assets/images/knowledge-node/234a36768ff31bf18d9f.png') center/cover no-repeat;
			z-index: 12;
			pointer-events: none;
		}
		.graph-header__inner {
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 16px;
			pointer-events: auto;
			padding: 0 60px;
			box-sizing: border-box;
			position: relative;
		}
		.graph-header__title {
			font-size: 34px;
			font-weight: 700;
			letter-spacing: 4px;
			color: #fff;
			text-shadow: 0 8px 25px rgba(0,0,0,0.55);
			text-align: center;
			flex: none;
		}
		.graph-search-toggle {
			position: absolute;
			right: 24px;
			top: 50%;
			transform: translateY(-50%);
			width: 44px;
			height: 44px;
			border-radius: 50%;
			border: 2px solid rgba(255,255,255,0.4);
			background: rgba(7,20,45,0.65);
			color: #fff;
			cursor: pointer;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			transition: transform 0.2s, border-color 0.2s, background 0.2s;
		}
		.graph-search-toggle:hover {
			transform: translateY(-50%) scale(1.08);
			border-color: #5dade2;
			background: rgba(19,44,92,0.9);
		}
		.graph-search-toggle svg {
			width: 22px;
			height: 22px;
		}

		/* Mac Spotlight é£æ ¼æœç´¢ */
		.search-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(2, 6, 23, 0.65);
			backdrop-filter: blur(10px);
			display: none;
			align-items: flex-start;
			justify-content: center;
			padding-top: 140px;
			z-index: 15;
		}
		.search-overlay.visible {
			display: flex;
		}
		.search-panel {
			width: min(900px, 92vw);
			background: rgba(11, 18, 35, 0.9);
			border-radius: 28px;
			padding: 28px 32px 32px;
			box-shadow: 0 25px 80px rgba(0,0,0,0.45);
			border: 1px solid rgba(255,255,255,0.08);
		}
		.search-panel__input {
			display: flex;
			align-items: center;
			gap: 16px;
			border-bottom: 1px solid rgba(255,255,255,0.08);
			padding-bottom: 18px;
			margin-bottom: 20px;
		}
		.search-panel__input svg {
			width: 26px;
			height: 26px;
			flex-shrink: 0;
		}
		.search-panel__input input {
			flex: 1;
			background: none;
			border: none;
			font-size: 24px;
			color: #fff;
			outline: none;
		}
		.search-panel__input input::placeholder {
			color: rgba(255,255,255,0.4);
		}
		.search-panel__close {
			background: none;
			border: none;
			color: rgba(255,255,255,0.7);
			font-size: 26px;
			cursor: pointer;
		}
		.search-results {
			max-height: 360px;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			gap: 14px;
			align-items: stretch;
		}
		.search-result {
			background: rgba(255,255,255,0.1);
			border-radius: 16px;
			padding: 18px 20px;
			border: 1px solid transparent;
			color: #f5f5f5;
			text-align: left;
			cursor: pointer;
			transition: border-color 0.2s, background 0.2s, transform 0.2s;
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.search-result:hover {
			border-color: rgba(91, 173, 226, 0.7);
			background: rgba(91, 173, 226, 0.18);
			transform: translateY(-2px);
		}
		.search-result__name {
			font-size: 20px;
			font-weight: 700;
		}
		.search-result__meta {
			font-size: 14px;
			color: rgba(255,255,255,0.7);
		}
		.search-result__desc {
			font-size: 13px;
			color: rgba(255,255,255,0.55);
		}
		.search-empty {
			text-align: center;
			color: rgba(255,255,255,0.6);
			padding: 26px 0;
			font-size: 16px;
		}

		/* åº•éƒ¨æ§åˆ¶æ¡ */
		.graph-controls {
			position: fixed;
			right: 40px;
			bottom: 40px;
			display: flex;
			align-items: center;
			gap: 4px;
			padding: 8px 12px;
			background: rgba(2, 8, 28, 0.75);
			border-radius: 16px;
			border: 1px solid rgba(255,255,255,0.08);
			box-shadow: 0 10px 30px rgba(0,0,0,0.45);
			z-index: 14;
			backdrop-filter: blur(8px);
		}
		.graph-controls button {
			background: transparent;
			border: none;
			color: #e5ecff;
			font-size: 14px;
			padding: 10px 14px;
			border-radius: 12px;
			display: inline-flex;
			align-items: center;
			gap: 6px;
			cursor: pointer;
			transition: background 0.2s, color 0.2s;
		}
		.graph-controls button:hover {
			background: rgba(91, 173, 226, 0.2);
			color: #fff;
		}
		.graph-settings-hint {
			position: fixed;
			right: 40px;
			bottom: 120px;
			padding: 10px 16px;
			background: rgba(7,20,45,0.9);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 12px;
			color: #e5ecff;
			box-shadow: 0 10px 30px rgba(0,0,0,0.45);
			font-size: 14px;
			opacity: 0;
			transform: translateY(10px);
			transition: opacity 0.25s ease, transform 0.25s ease;
			z-index: 16;
			pointer-events: none;
		}
		.graph-settings-hint.visible {
			opacity: 1;
			transform: translateY(0);
		}

		/* èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ */
		.node-info-panel {
			position: fixed;
			left: 40px;
			bottom: 40px;
			max-width: 420px;
			color: #dbe9ff;
			font-size: 14px;
			line-height: 1.6;
			z-index: 14;
			pointer-events: none;
			opacity: 0;
			transform: translateY(10px);
			transition: opacity 0.25s, transform 0.25s;
			display: none;
		}
		.node-info-panel.visible {
			opacity: 1;
			transform: translateY(0);
		}
		.node-info-panel__title {
			font-size: 22px;
			font-weight: 700;
			margin-bottom: 10px;
			text-shadow: 0 0 12px rgba(0,0,0,0.6);
		}
		.node-info-panel__prop {
			display: flex;
			margin-bottom: 6px;
			gap: 6px;
		}
		.node-info-panel__key {
			color: rgba(255,255,255,0.6);
		}
		.node-info-panel__value {
			color: #fff;
		}

		/* Hover/Search çŠ¶æ€ */
		.links line.hover-dim,
		.nodes circle.hover-dim,
		.texts text.hover-dim {
			opacity: 0.15;
		}
		.links line.hover-focus {
			stroke-opacity: 0.95;
			stroke-width: 3px;
		}
		.nodes circle.hover-focus {
			stroke-width: 4px;
		}
		.texts text.hover-focus {
			opacity: 1;
		}
		.links line.search-dim,
		.nodes circle.search-dim,
		.texts text.search-dim {
			opacity: 0.08 !important;
		}
		.nodes circle.search-match {
			stroke: #5dade2;
			stroke-width: 4px;
			filter: drop-shadow(0 0 12px rgba(93,173,226,0.45));
		}
		.texts text.search-match {
			fill: #fff;
			stroke: rgba(93,173,226,0.6);
		}
		.links line.search-match {
			stroke: rgba(93,173,226,0.9);
			stroke-width: 3px;
		}
		.nodes circle.search-related {
			stroke: rgba(255,255,255,0.5);
		}

		@media (max-width: 768px) {
			.graph-controls {
				right: 16px;
				bottom: 16px;
				flex-wrap: wrap;
			}
			.graph-header {
				height: 90px;
			}
			.graph-header__title {
				font-size: 22px;
			}
			.node-info-panel {
				left: 16px;
				right: 16px;
				bottom: 120px;
			}
			.search-panel {
				padding: 20px;
			}
		}

		/* åŠ©æ‰‹é¢æ¿ï¼šä¾¿åˆ©è´´é£æ ¼ */
		.assistant-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 200px;
			background: #fff9c4; /* é»„è‰²ä¾¿åˆ©è´´ */
			border: 2px solid var(--line-ink);
			border-radius: 2px 2px 20px 2px; /* å³ä¸‹è§’ç¨å¾®å·èµ· */
			padding: 16px;
			color: var(--line-ink);
			box-shadow: var(--shadow-sketch);
			pointer-events: auto;
			z-index: 10;
			transform: rotate(-2deg); /* ç¨å¾®æ­ªä¸€ç‚¹ */
			transition: transform 0.2s;
		}
		.assistant-panel:hover {
			transform: rotate(0deg) scale(1.02);
		}
		.assistant-panel h3 {
			margin: 0 0 8px 0;
			font-size: 20px;
			font-weight: 900;
			border-bottom: 2px dashed var(--line-ink);
			padding-bottom: 4px;
		}
		.assistant-panel p {
			margin: 8px 0 16px;
			font-size: 16px;
			line-height: 1.3;
		}

		/* æŒ‰é’®ï¼šæ‰‹ç»˜é£æ ¼ */
		.assistant-launch, .assistant-button, .copy-button {
			width: 100%;
			border: 2px solid var(--line-ink);
			border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px; /* ä¸è§„åˆ™åœ†è§’ */
			padding: 8px 12px;
			background: #ffccbc; /* æµ…çº¢ */
			color: var(--line-ink);
			font-family: var(--font-hand);
			font-weight: 700;
			font-size: 16px;
			cursor: pointer;
			box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
			transition: all 0.1s ease;
		}
		.assistant-launch:hover, .assistant-button:hover {
			transform: translate(-2px, -2px);
			box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
			background: #ffab91;
		}
		.assistant-launch:active, .assistant-button:active {
			transform: translate(0, 0);
			box-shadow: 0 0 0;
		}

		/* æ¨¡æ€æ¡†ï¼šç´ ææœ¬é£æ ¼ */
		.assistant-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: none;
			align-items: center;
			justify-content: center;
			background: rgba(255, 255, 255, 0.6);
			backdrop-filter: blur(2px);
			z-index: 20;
		}
		.assistant-modal.visible {
			display: flex;
		}
		.assistant-modal__dialog {
			width: min(550px, calc(100% - 32px));
			max-height: calc(100% - 64px);
			overflow-y: auto;
			background: #ffffff;
			border: 3px solid var(--line-ink);
			border-radius: 12px;
			padding: 24px;
			box-shadow: 8px 8px 0px rgba(0,0,0,0.15);
			position: relative;
		}
		/* æ¨¡æ€æ¡†é¡¶éƒ¨çš„è£…è®¢çº¿æ•ˆæœ */
		.assistant-modal__dialog::before {
			content: "";
			position: absolute;
			top: 10px;
			left: 0;
			right: 0;
			height: 20px;
			background-image: repeating-linear-gradient(90deg, transparent, transparent 19px, var(--line-ink) 19px, var(--line-ink) 21px, transparent 21px, transparent 40px);
			background-size: 40px 100%;
			opacity: 0.2;
			pointer-events: none;
		}

		.assistant-modal__header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 16px;
		}
		.assistant-modal__title {
			font-size: 24px;
			font-weight: 900;
			color: var(--line-ink);
		}
		.assistant-close {
			background: none;
			border: none;
			color: var(--line-ink);
			font-size: 32px;
			font-family: var(--font-hand);
			cursor: pointer;
			line-height: 0.8;
		}
		
		.assistant-input {
			width: 100%;
			min-height: 100px;
			border: 2px solid var(--line-ink);
			border-radius: 8px;
			padding: 12px;
			background: #f0f4c3; /* æµ…ç»¿çº¸å¼  */
			color: var(--line-ink);
			font-family: var(--font-hand);
			font-size: 18px;
			resize: vertical;
			outline: none;
			box-sizing: border-box;
		}
		.assistant-input:focus {
			background: #fff;
			box-shadow: inset 2px 2px 5px rgba(0,0,0,0.05);
		}

		.assistant-actions {
			display: flex;
			gap: 10px;
			margin-top: 15px;
		}
		.copy-button {
			width: auto;
			background: #b2dfdb; /* æµ…é’ */
		}

		.assistant-result {
			margin-top: 15px;
			padding: 16px;
			border-radius: 8px;
			background: #eeeeee;
			border: 2px dashed var(--line-ink);
			position: relative;
		}
		.assistant-result pre {
			font-family: 'Consolas', 'Monaco', monospace; /* ä»£ç è¿˜æ˜¯è¦ç”¨ç­‰å®½å­—ä½“ */
			font-size: 14px;
			color: #333;
			white-space: pre-wrap;
			margin: 0;
		}
		
		.assistant-tip {
			margin-top: 15px;
			font-size: 14px;
			color: #666;
			background: rgba(0,0,0,0.05);
			padding: 8px;
			border-radius: 4px;
		}
	</style>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/neo4j-driver"></script>
	<!-- ä»£ç é«˜äº®æ ·å¼æ”¹ä¸ºæµ…è‰²ä¸»é¢˜ -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css">
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
	<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
	<svg id="svg1"></svg>
	<header class="graph-header">
		<div class="graph-header__inner">
			<div class="graph-header__title">çŸ¥ è¯† å›¾ è°±</div>
			<button class="graph-search-toggle" id="graphSearchToggle" aria-label="å¼€å¯æœç´¢">
				<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<circle cx="11" cy="11" r="7"></circle>
					<line x1="16.65" y1="16.65" x2="21" y2="21"></line>
				</svg>
			</button>
		</div>
	</header>

	<div class="search-overlay" id="searchOverlay" aria-hidden="true">
		<div class="search-panel">
			<form id="searchForm" autocomplete="off">
				<div class="search-panel__input">
					<svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="#7fb3ff" stroke-width="2">
						<circle cx="11" cy="11" r="7"></circle>
						<line x1="16.65" y1="16.65" x2="21" y2="21"></line>
					</svg>
					<input id="searchInput" type="text" placeholder="æœç´¢èŠ‚ç‚¹ã€æŠ€èƒ½æˆ–äººç‰©..." />
					<button type="button" class="search-panel__close" id="searchClose" aria-label="å…³é—­æœç´¢">Ã—</button>
				</div>
			</form>
			<div class="search-results" id="searchResults">
				<div class="search-empty">è¾“å…¥å…³é”®è¯ä»¥æœç´¢èŠ‚ç‚¹</div>
			</div>
		</div>
	</div>

	<div class="node-info-panel" id="nodeInfoPanel" aria-live="polite"></div>

	<div class="graph-controls" id="graphControls">
		<button type="button" data-action="fullscreen">â›¶ å…¨å±</button>
		<button type="button" data-action="reset">âŸ² è¿˜åŸ</button>
		<button type="button" data-action="zoom-in">ï¼‹ æ”¾å¤§</button>
		<button type="button" data-action="zoom-out">ï¼ ç¼©å°</button>
		<button type="button" data-action="settings">âš™ è®¾ç½®</button>
	</div>

	<div class="graph-settings-hint" id="graphSettingsHint">è®¾ç½®é¢æ¿å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…ï½</div>
	
	<div class="assistant-panel" id="assistantPanel">
		<h3>ğŸ–ï¸ çŸ¥è¯†åŠ©æ‰‹</h3>
		<p>æƒ³æŸ¥ä»€ä¹ˆï¼Ÿæˆ‘æ¥å¸®ä½ æŠŠè‡ªç„¶è¯­è¨€å˜æˆ Cypher ä»£ç ï¼</p>
		<button class="assistant-launch" id="assistantLaunch">âœ¨ å‘¼å«åŠ©æ‰‹</button>
	</div>

	<div class="assistant-modal" id="assistantModal" aria-hidden="true">
		<div class="assistant-modal__dialog">
			<div class="assistant-modal__header">
				<div>
					<div class="assistant-modal__title">âœï¸ çŸ¥è¯†å°åŠ©æ‰‹</div>
					<div style="font-size:16px;color:#666;margin-top:4px;">è‡ªç„¶è¯­è¨€è½¬ Cypher (æ”¯æŒ Markdown)</div>
				</div>
				<button class="assistant-close" id="assistantClose" aria-label="å…³é—­">Ã—</button>
			</div>
			<form id="assistantForm">
				<textarea id="assistantInput" class="assistant-input" placeholder="æ¯”å¦‚ï¼šå¸®æˆ‘æ‰¾æ‰¾æ‰€æœ‰æ“…é•¿â€œPythonâ€çš„å† å†›é˜Ÿä¼..."></textarea>
				<div class="assistant-actions">
					<button type="submit" id="assistantSubmit" class="assistant-button">ğŸ¨ ç”Ÿæˆä»£ç </button>
					<button type="button" id="assistantCopy" class="copy-button" disabled>ğŸ“„ å¤åˆ¶</button>
				</div>
				<div id="assistantStatus" class="assistant-status" style="margin-top:8px; font-size:14px;"></div>
				<div class="assistant-result">
					<div id="assistantResult" class="assistant-empty">ç­‰å¾…ä½ çš„çµæ„Ÿ...</div>
				</div>
				<div class="assistant-tip">
					<strong>ğŸ’¡ æç¤ºï¼š</strong> å¦‚æœé‡åˆ° CORS è·¨åŸŸé—®é¢˜ï¼Œè®°å¾—å»åç«¯å¼€å¯ 8121 ç«¯å£çš„æƒé™å“¦ã€‚
				</div>
			</form>
		</div>
	</div>
	
	<script type="text/javascript">
		document.addEventListener('DOMContentLoaded', function() {
			// -----------------------------
			// 1. åŠ©æ‰‹åŠŸèƒ½é€»è¾‘ (ä¿æŒåŠŸèƒ½ä¸å˜)
			// -----------------------------
			const TEXT2CYPHER_ENDPOINT = 'http://localhost:8121/api/mcp/text2cypher';
			const assistantElements = {
				form: document.getElementById('assistantForm'),
				input: document.getElementById('assistantInput'),
				submit: document.getElementById('assistantSubmit'),
				copy: document.getElementById('assistantCopy'),
				status: document.getElementById('assistantStatus'),
				result: document.getElementById('assistantResult'),
				launch: document.getElementById('assistantLaunch'),
				modal: document.getElementById('assistantModal'),
				close: document.getElementById('assistantClose')
			};

			const graphUI = {
				searchToggle: document.getElementById('graphSearchToggle'),
				searchOverlay: document.getElementById('searchOverlay'),
				searchForm: document.getElementById('searchForm'),
				searchInput: document.getElementById('searchInput'),
				searchResults: document.getElementById('searchResults'),
				searchClose: document.getElementById('searchClose'),
				controls: document.getElementById('graphControls'),
				infoPanel: document.getElementById('nodeInfoPanel')
			};

			const graphState = {
				nodes: [],
				links: [],
				nodeSelection: null,
				linkSelection: null,
				textSelection: null,
				simulation: null,
				zoomBehavior: null,
				container: null,
				currentZoom: d3.zoomIdentity,
				hoveredNodeId: null,
				pinnedNodeId: null,
				pendingSearch: null
			};
			
			if (window.marked) {
				marked.setOptions({
					breaks: true,
					highlight: function(code, lang) {
						if (lang && window.hljs && hljs.getLanguage(lang)) {
							return hljs.highlight(code, { language: lang }).value;
						}
						return window.hljs ? hljs.highlightAuto(code).value : code;
					}
				});
			}
			
			function toggleModal(show) {
				if (!assistantElements.modal) return;
				if (show) {
					assistantElements.modal.classList.add('visible');
					assistantElements.modal.setAttribute('aria-hidden', 'false');
				} else {
					assistantElements.modal.classList.remove('visible');
					assistantElements.modal.setAttribute('aria-hidden', 'true');
				}
			}
			
			if (assistantElements.launch) {
				assistantElements.launch.addEventListener('click', function() {
					toggleModal(true);
					setTimeout(() => assistantElements.input.focus(), 100);
				});
			}
			if (assistantElements.close) {
				assistantElements.close.addEventListener('click', function() {
					toggleModal(false);
				});
			}
			if (assistantElements.modal) {
				assistantElements.modal.addEventListener('click', function(event) {
					if (event.target === assistantElements.modal) {
						toggleModal(false);
					}
				});
			}
			
			function setAssistantStatus(message, tone) {
				const colors = {
					info: '#7986cb',
					success: '#4db6ac',
					error: '#e57373'
				};
				assistantElements.status.style.color = colors[tone] || colors.info;
				assistantElements.status.textContent = message || '';
			}
			
			function setAssistantLoading(isLoading) {
				assistantElements.submit.disabled = isLoading;
				assistantElements.submit.textContent = isLoading ? 'ğŸ¨ ç»˜åˆ¶ä¸­...' : 'ğŸ¨ ç”Ÿæˆ Cypher';
			}
			
			function renderCypher(text) {
				if (text) {
					let rendered = text;
					if (window.marked && typeof marked.parse === 'function') {
						rendered = marked.parse(text);
					}
					assistantElements.result.innerHTML = rendered;
					assistantElements.result.classList.remove('assistant-empty');
					assistantElements.copy.disabled = false;
					if (window.MathJax && MathJax.typesetPromise) {
						MathJax.typesetPromise([assistantElements.result]).catch(function(err) {});
					}
					if (window.hljs) {
						assistantElements.result.querySelectorAll('pre code').forEach(block => {
							hljs.highlightElement(block);
						});
					}
				} else {
					assistantElements.result.textContent = 'æš‚æœªè·å–åˆ° Cypher ç»“æœ';
					assistantElements.result.classList.add('assistant-empty');
					assistantElements.copy.disabled = true;
				}
			}
			
			function requestCypher(question) {
				const trimmed = question.trim();
				if (!trimmed) {
					setAssistantStatus('å†™ç‚¹ä»€ä¹ˆå§...', 'error');
					renderCypher('');
					return;
				}
				
				setAssistantLoading(true);
				setAssistantStatus('æ­£åœ¨å‘¼å«æ™ºèƒ½åŠ©æ‰‹...', 'info');
				renderCypher('è¯·ç¨å€™ï¼Œæ­£åœ¨æ„æ€...');
				
				const url = TEXT2CYPHER_ENDPOINT + '?question=' + encodeURIComponent(trimmed);
				fetch(url, { method: 'GET' })
					.then(resp => {
						if (!resp.ok) throw new Error('æ¥å£è¿”å›çŠ¶æ€ç  ' + resp.status);
						return resp.json();
					})
					.then(data => {
						if (data && data.code === 0 && data.data) {
							renderCypher(data.data);
							setAssistantStatus('æå®šå•¦ï¼', 'success');
						} else {
							const msg = (data && (data.message || data.msg)) || 'æœªçŸ¥é”™è¯¯';
							renderCypher('');
							setAssistantStatus('å“å‘€ï¼š' + msg, 'error');
						}
					})
					.catch(err => {
						renderCypher('');
						const corsHint = err.message && err.message.includes('Failed to fetch') ? 'ï¼ˆå¯èƒ½æ˜¯è·¨åŸŸé—®é¢˜ï¼‰' : '';
						setAssistantStatus('è¯·æ±‚å¤±è´¥ï¼š' + err.message + corsHint, 'error');
					})
					.finally(() => {
						setAssistantLoading(false);
					});
			}
			
			assistantElements.form.addEventListener('submit', function(e) {
				e.preventDefault();
				requestCypher(assistantElements.input.value);
			});
			
			assistantElements.copy.addEventListener('click', function() {
				const text = assistantElements.result.innerText;
				if (!text || assistantElements.copy.disabled) return;
				navigator.clipboard.writeText(text.trim()).then(function() {
					setAssistantStatus('å¤åˆ¶å¥½å•¦ï¼', 'success');
				}).catch(function() {
					setAssistantStatus('å¤åˆ¶å¤±è´¥', 'error');
				});
			});
			
			const panel = document.getElementById('assistantPanel');
			if (panel) {
				panel.addEventListener('mousedown', function(event) {
					if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'BUTTON') return;
					let startX = event.clientX;
					let startY = event.clientY;
					const rect = panel.getBoundingClientRect();
					const offsetX = startX - rect.left;
					const offsetY = startY - rect.top;
					
					function onMouseMove(e) {
						panel.style.left = Math.min(window.innerWidth - panel.offsetWidth - 16, Math.max(16, e.clientX - offsetX)) + 'px';
						panel.style.top = Math.min(window.innerHeight - panel.offsetHeight - 16, Math.max(16, e.clientY - offsetY)) + 'px';
						panel.style.right = 'unset';
					}
					
					function onMouseUp() {
						document.removeEventListener('mousemove', onMouseMove);
						document.removeEventListener('mouseup', onMouseUp);
					}
					
					document.addEventListener('mousemove', onMouseMove);
					document.addEventListener('mouseup', onMouseUp);
				});
			}
			
			// -----------------------------
			// 1.5 æœç´¢ã€ä¿¡æ¯é¢æ¿ä¸è§†å›¾æ§åˆ¶
			// -----------------------------
			let searchInputTimer = null;

			function toggleSearchOverlay(forceState) {
				if (!graphUI.searchOverlay) return;
				const isVisible = graphUI.searchOverlay.classList.contains('visible');
				const shouldShow = typeof forceState === 'boolean' ? forceState : !isVisible;
				graphUI.searchOverlay.classList.toggle('visible', shouldShow);
				graphUI.searchOverlay.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
				if (shouldShow && graphUI.searchInput) {
					setTimeout(() => graphUI.searchInput.focus(), 150);
				}
			}

			function renderSearchResults(list, keyword) {
				if (!graphUI.searchResults) return;
				const container = graphUI.searchResults;
				container.innerHTML = '';
				if (!keyword) {
					container.innerHTML = '<div class="search-empty">è¾“å…¥å…³é”®è¯ä»¥æœç´¢èŠ‚ç‚¹</div>';
					return;
				}
				if (!list || list.length === 0) {
					container.innerHTML = '<div class="search-empty">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„èŠ‚ç‚¹</div>';
					return;
				}
				const fragment = document.createDocumentFragment();
				list.forEach(node => {
					const button = document.createElement('button');
					button.type = 'button';
					button.className = 'search-result';
					button.dataset.nodeId = node.id;
					button.innerHTML = `
						<div class="search-result__name">${node.properties.name || node.id}</div>
						<div class="search-result__meta">${node.label || 'èŠ‚ç‚¹'}</div>
						<div class="search-result__desc">${formatNodeSummary(node)}</div>
					`;
					fragment.appendChild(button);
				});
				container.appendChild(fragment);
			}

			function formatNodeSummary(node) {
				if (!node || !node.properties) return 'æš‚æ— å±æ€§';
				const entries = Object.entries(node.properties).filter(([key]) => key !== 'name');
				if (!entries.length) return 'æš‚æ— æ›´è¯¦ç»†çš„å±æ€§';
				return entries.slice(0, 2).map(([key, value]) => `${key}: ${value}`).join(' Â· ');
			}

			function getLinkNodeId(value) {
				if (!value) return null;
				if (typeof value === 'object' && value.id !== undefined) return value.id;
				return value;
			}

			function getConnectedNodeIds(centerId) {
				const ids = new Set([centerId]);
				graphState.links.forEach(link => {
					const sourceId = getLinkNodeId(link.source);
					const targetId = getLinkNodeId(link.target);
					if (sourceId === centerId) ids.add(targetId);
					if (targetId === centerId) ids.add(sourceId);
				});
				return ids;
			}

			function clearHoverState() {
				graphState.hoveredNodeId = null;
				if (!graphState.nodeSelection) return;
				graphState.nodeSelection.classed('hover-focus', false).classed('hover-dim', false);
				graphState.linkSelection.classed('hover-focus', false).classed('hover-dim', false);
				graphState.textSelection.classed('hover-focus', false).classed('hover-dim', false);
			}

			function applyHoverState(node) {
				if (!node || !graphState.nodeSelection) return;
				graphState.hoveredNodeId = node.id;
				const connected = getConnectedNodeIds(node.id);
				graphState.nodeSelection
					.classed('hover-focus', d => connected.has(d.id))
					.classed('hover-dim', d => !connected.has(d.id));
				graphState.linkSelection
					.classed('hover-focus', l => {
						const sourceId = getLinkNodeId(l.source);
						const targetId = getLinkNodeId(l.target);
						return sourceId === node.id || targetId === node.id;
					})
					.classed('hover-dim', l => {
						const sourceId = getLinkNodeId(l.source);
						const targetId = getLinkNodeId(l.target);
						return sourceId !== node.id && targetId !== node.id;
					});
				graphState.textSelection
					.classed('hover-focus', d => connected.has(d.id))
					.classed('hover-dim', d => !connected.has(d.id));
			}

			function clearSearchHighlights() {
				if (!graphState.nodeSelection) return;
				graphState.nodeSelection.classed('search-match', false).classed('search-related', false).classed('search-dim', false);
				graphState.linkSelection.classed('search-match', false).classed('search-dim', false);
				graphState.textSelection.classed('search-match', false).classed('search-dim', false);
			}

			function highlightSearchMatches(matches) {
				clearSearchHighlights();
				if (!matches || !matches.length || !graphState.nodeSelection) return;
				const matchedIds = new Set(matches.map(node => node.id));
				const relatedIds = new Set();
				graphState.links.forEach(link => {
					const sourceId = getLinkNodeId(link.source);
					const targetId = getLinkNodeId(link.target);
					const sourceMatched = matchedIds.has(sourceId);
					const targetMatched = matchedIds.has(targetId);
					if (sourceMatched && !matchedIds.has(targetId)) relatedIds.add(targetId);
					if (targetMatched && !matchedIds.has(sourceId)) relatedIds.add(sourceId);
				});
				graphState.nodeSelection
					.classed('search-match', d => matchedIds.has(d.id))
					.classed('search-related', d => relatedIds.has(d.id))
					.classed('search-dim', d => !matchedIds.has(d.id) && !relatedIds.has(d.id));
				graphState.linkSelection
					.classed('search-match', l => {
						const sourceId = getLinkNodeId(l.source);
						const targetId = getLinkNodeId(l.target);
						return matchedIds.has(sourceId) || matchedIds.has(targetId);
					})
					.classed('search-dim', l => {
						const sourceId = getLinkNodeId(l.source);
						const targetId = getLinkNodeId(l.target);
						return !matchedIds.has(sourceId) && !matchedIds.has(targetId);
					});
				graphState.textSelection
					.classed('search-match', d => matchedIds.has(d.id))
					.classed('search-dim', d => !matchedIds.has(d.id) && !relatedIds.has(d.id));
			}

			function showInfoPanel(node, options = {}) {
				if (!graphUI.infoPanel || !node) return;
				const { pin = false, preservePin = false } = options;
				if (pin) {
					graphState.pinnedNodeId = node.id;
				} else if (!preservePin) {
					graphState.pinnedNodeId = null;
				}
				const style = getStyle(node.label);
				const props = node.properties || {};
				const hiddenKeys = new Set(['detail', 'è¯¦æƒ…']);
				const entries = Object.entries(props).filter(([key, value]) => {
					if (!value) return false;
					if (key === 'name') return false;
					return !hiddenKeys.has(String(key).toLowerCase());
				});
				const propsHtml = entries.length ? entries.slice(0, 6).map(([key, value]) => (
					`<div class="node-info-panel__prop"><span class="node-info-panel__key">${key}</span><span class="node-info-panel__value">${value}</span></div>`
				)).join('') : '<div class="node-info-panel__prop node-info-panel__value">æš‚æ— æ›´å¤šå±æ€§</div>';
				graphUI.infoPanel.innerHTML = `
					<div class="node-info-panel__title" style="color:${style.color || '#fff'}">${props.name || node.id}</div>
					${propsHtml}
				`;
				graphUI.infoPanel.classList.add('visible');
			}

			function hideInfoPanel(force = false) {
				if (!graphUI.infoPanel) return;
				if (!force && graphState.pinnedNodeId) return;
				graphState.pinnedNodeId = null;
				graphUI.infoPanel.classList.remove('visible');
				graphUI.infoPanel.innerHTML = '';
			}

			function notifyParent(type, payload) {
				if (!window.parent) return;
				window.parent.postMessage({ type, ...payload }, window.location.origin);
			}

			function focusOnNode(node, options = {}) {
				if (!node || !graphState.zoomBehavior) return;
				const scale = options.scale || Math.max(1.2, graphState.currentZoom.k || 1);
				const translateX = window.innerWidth / 2 - node.x * scale;
				const translateY = window.innerHeight / 2 - node.y * scale;
				const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
				d3.select('#svg1').transition().duration(600).call(graphState.zoomBehavior.transform, transform);
			}

			function zoomBy(factor) {
				if (!graphState.zoomBehavior) return;
				d3.select('#svg1').transition().duration(350).call(graphState.zoomBehavior.scaleBy, factor);
			}

			function resetGraphView() {
				if (!graphState.zoomBehavior) return;
				graphState.pinnedNodeId = null;
				clearHoverState();
				clearSearchHighlights();
				hideInfoPanel(true);
				notifyParent('nodeDeselected', {});
				d3.select('#svg1').transition().duration(500).call(graphState.zoomBehavior.transform, d3.zoomIdentity);
			}

			function toggleFullscreen() {
				const doc = window.document;
				const docEl = doc.documentElement;
				const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
				const exitFull = doc.exitFullscreen || doc.webkitExitFullscreen || doc.mozCancelFullScreen || doc.msExitFullscreen;
				if (!doc.fullscreenElement && !doc.webkitFullscreenElement && !doc.mozFullScreenElement) {
					if (requestFull) requestFull.call(docEl);
				} else if (exitFull) {
					exitFull.call(doc);
				}
			}

			let settingsHintTimer = null;
			function showSettingsHint() {
				const hint = document.getElementById('graphSettingsHint');
				if (!hint) return;
				hint.classList.add('visible');
				clearTimeout(settingsHintTimer);
				settingsHintTimer = setTimeout(() => hint.classList.remove('visible'), 2200);
			}

			function handleControlAction(action) {
				switch (action) {
					case 'fullscreen':
						toggleFullscreen();
						break;
					case 'reset':
						resetGraphView();
						break;
					case 'zoom-in':
						zoomBy(1.2);
						break;
					case 'zoom-out':
						zoomBy(0.8);
						break;
					case 'settings':
						showSettingsHint();
						break;
					default:
						break;
				}
			}

			function runSearch(keyword) {
				const trimmed = (keyword || '').trim();
				if (!graphState.nodes.length) {
					graphState.pendingSearch = trimmed;
					return;
				}
				if (!graphUI.searchInput) return;
				const lower = trimmed.toLowerCase();
				const matches = trimmed ? graphState.nodes.filter(node => {
					const name = (node.properties.name || '').toLowerCase();
					const label = (node.label || '').toLowerCase();
					return name.includes(lower) || label.includes(lower);
				}) : [];
				renderSearchResults(matches, trimmed);
				if (!trimmed) {
					clearSearchHighlights();
					hideInfoPanel(true);
					notifyParent('nodeDeselected', {});
					return;
				}
				highlightSearchMatches(matches);
				if (matches.length) {
					const target = matches[0];
					showInfoPanel(target, { pin: true });
					focusOnNode(target);
					notifyParent('nodeSelected', {
						name: target.properties.name,
						color: getStyle(target.label).color,
						properties: target.properties
					});
				} else {
					hideInfoPanel(true);
					notifyParent('nodeDeselected', {});
				}
			}

			function handleExternalMessage(event) {
				if (event.origin !== window.location.origin) return;
				if (!event.data || event.data.type !== 'search') return;
				const keyword = event.data.keyword || '';
				if (graphUI.searchInput) {
					graphUI.searchInput.value = keyword;
				}
				toggleSearchOverlay(true);
				runSearch(keyword);
			}

			if (graphUI.searchToggle) {
				graphUI.searchToggle.addEventListener('click', () => toggleSearchOverlay(true));
			}
			if (graphUI.searchClose) {
				graphUI.searchClose.addEventListener('click', () => toggleSearchOverlay(false));
			}
			if (graphUI.searchOverlay) {
				graphUI.searchOverlay.addEventListener('click', event => {
					if (event.target === graphUI.searchOverlay) toggleSearchOverlay(false);
				});
			}
			if (graphUI.searchForm && graphUI.searchInput) {
				graphUI.searchForm.addEventListener('submit', event => {
					event.preventDefault();
					runSearch(graphUI.searchInput.value);
				});
				graphUI.searchInput.addEventListener('input', () => {
					clearTimeout(searchInputTimer);
					searchInputTimer = setTimeout(() => runSearch(graphUI.searchInput.value), 200);
				});
			}
			if (graphUI.searchResults) {
				graphUI.searchResults.addEventListener('click', event => {
					const target = event.target.closest('.search-result');
					if (!target) return;
					const node = graphState.nodes.find(n => n.id === target.dataset.nodeId);
					if (node) {
						showInfoPanel(node, { pin: true });
						focusOnNode(node, { scale: 1.4 });
						highlightSearchMatches([node]);
						notifyParent('nodeSelected', {
							name: node.properties.name,
							color: getStyle(node.label).color,
							properties: node.properties
						});
					}
				});
			}
			if (graphUI.controls) {
				graphUI.controls.addEventListener('click', event => {
					const button = event.target.closest('button[data-action]');
					if (!button) return;
					handleControlAction(button.dataset.action);
				});
			}
			document.addEventListener('keydown', event => {
				if (event.key === 'Escape') {
					if (graphUI.searchOverlay && graphUI.searchOverlay.classList.contains('visible')) {
						toggleSearchOverlay(false);
					}
				}
			});

			window.addEventListener('message', handleExternalMessage);
			
			// -----------------------------
			// 2. å›¾è°±å¯è§†åŒ–é…ç½® (D3 + Style)
			// -----------------------------
			
			// å®šä¹‰å¯çˆ±é£æ ¼çš„é…è‰²å’Œå¤§å°é…ç½®
			// é©¬å¡é¾™è‰²ç³» + å±‚çº§å¤§å°å®šä¹‰
			const NODE_STYLES = {
				'Enterprise': { color: '#ffb7b2', radius: 40, rank: 1 }, // çŠç‘šçº¢ - å¤§
				'Competition': { color: '#ffdac1', radius: 35, rank: 2 }, // èœœæ¡ƒæ©™ - ä¸­å¤§
				'Project': { color: '#e2f0cb', radius: 30, rank: 3 },    // æŠ¹èŒ¶ç»¿ - ä¸­
				'Team': { color: '#b5ead7', radius: 25, rank: 4 },       // è–„è·è“ - ä¸­å°
				'Skill': { color: '#c7ceea', radius: 20, rank: 5 },      // è–°è¡£è‰ç´« - å°
				'Mentor': { color: '#e0f2f1', radius: 20, rank: 5 },     // æµ…é’ - å°
				'Person': { color: '#fff9c4', radius: 18, rank: 6 },     // æµ…é»„ - å°
				'default': { color: '#f5f5f5', radius: 15, rank: 7 }     // é»˜è®¤ç°
			};
			
			// å¤‡ç”¨é¢œè‰²ç”Ÿæˆå™¨ï¼ˆæ‰‹ç»˜é£æ ¼é€šå¸¸é¢œè‰²è¾ƒæµ…ï¼‰
			function getRandomPastelColor(str) {
				let hash = 0;
				for (let i = 0; i < str.length; i++) {
					hash = str.charCodeAt(i) + ((hash << 5) - hash);
				}
				const h = hash % 360;
				return `hsl(${h}, 70%, 85%)`; // é«˜æ˜åº¦ï¼Œä½é¥±å’Œåº¦
			}

			const LABEL_BLACKLIST = new Set(['Country', 'Region', 'Type', 'Framework', 'Tool', 'Concept', 'Genre', 'Equipment', 'Technique']);
			
			var svg = d3.select("#svg1"),
				width = window.innerWidth,
				height = window.innerHeight;

			const stage = svg.append("g").attr("class", "graph-stage");
			graphState.container = stage;
			graphState.currentZoom = d3.zoomIdentity;
			graphState.zoomBehavior = d3.zoom()
				.scaleExtent([0.4, 2.8])
				.on("zoom", function() {
					graphState.currentZoom = d3.event.transform;
					if (graphState.container) {
						graphState.container.attr("transform", graphState.currentZoom);
					}
				});
			svg.call(graphState.zoomBehavior);
			svg.on("click", function() {
				if (d3.event.target && d3.event.target.tagName === 'svg') {
					clearHoverState();
					hideInfoPanel(true);
					graphState.pinnedNodeId = null;
					notifyParent('nodeDeselected', {});
				}
			});
				
			// --- æ³¨å…¥ SVG æ»¤é•œ (å…³é”®æ­¥éª¤ï¼šåˆ¶é€ æ‰‹ç»˜æ•ˆæœ) ---
			var defs = svg.append("defs");
			
			// æ»¤é•œ1ï¼šçº¿æ¡æŠ–åŠ¨ (Sketch Line)
			var filterLine = defs.append("filter")
				.attr("id", "sketch-line")
				.attr("height", "130%");
			filterLine.append("feTurbulence")
				.attr("type", "fractalNoise")
				.attr("baseFrequency", "0.5") // é¢‘ç‡è¶Šé«˜è¶Šæ¯›ç³™
				.attr("numOctaves", "1")
				.attr("result", "noise");
			filterLine.append("feDisplacementMap")
				.attr("in", "SourceGraphic")
				.attr("in2", "noise")
				.attr("scale", "2"); // åç§»é‡

			// æ»¤é•œ2ï¼šå½¢çŠ¶ä¸è§„åˆ™ (Sketch Shape)
			var filterShape = defs.append("filter")
				.attr("id", "sketch-shape")
				.attr("x", "-20%")
				.attr("y", "-20%")
				.attr("width", "140%")
				.attr("height", "140%");
			filterShape.append("feTurbulence")
				.attr("type", "fractalNoise")
				.attr("baseFrequency", "0.03") // é¢‘ç‡ä½ä¸€ç‚¹ï¼Œäº§ç”Ÿå¤§çš„å˜å½¢
				.attr("numOctaves", "3")
				.attr("result", "noise");
			filterShape.append("feDisplacementMap")
				.attr("in", "SourceGraphic")
				.attr("in2", "noise")
				.attr("scale", "3"); // å˜å½¢ç¨‹åº¦
			// --------------------------------------------
			
			svg.attr("width", width).attr("height", height);
			
			window.addEventListener('resize', function() {
				width = window.innerWidth;
				height = window.innerHeight;
				svg.attr("width", width).attr("height", height);
				if (simulation) {
					simulation.force("center", d3.forceCenter(width / 2, height / 2));
					simulation.alpha(0.2).restart();
				}
			});
			
			const NEO4J_CONFIG = {
				url: "bolt://localhost:7687",
				user: "neo4j",
				password: "12345678"
			};

			function identityToString(id) {
				if (id == null) return '';
				if (typeof id === 'object' && typeof id.toString === 'function') return id.toString();
				return String(id);
			}
			
			// åŠ è½½æ•°æ®
			function loadGraphData() {
				if (window.neo4j && NEO4J_CONFIG && NEO4J_CONFIG.url) {
					let driver;
					try {
						driver = neo4j.driver(NEO4J_CONFIG.url, neo4j.auth.basic(NEO4J_CONFIG.user, NEO4J_CONFIG.password));
						const session = driver.session({ defaultAccessMode: neo4j.session.READ });
						const cypher = 'MATCH p=()-[r]->() RETURN p LIMIT 150'; // ç¨å¾®å‡å°‘èŠ‚ç‚¹æ•°ä¿æŒæ¸…çˆ½
						return session.run(cypher).then(result => {
							const data = result.records.map(rec => ({ p: rec.get('p') }));
							session.close(); driver.close();
							return data;
						}).catch(err => {
							console.warn('Neo4jè¿æ¥å¤±è´¥ï¼Œåˆ‡æ¢åˆ°æ¼”ç¤ºæ¨¡å¼');
							if(session) session.close(); if(driver) driver.close();
							return getMockData(); // ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
						});
					} catch (e) {
						return getMockData();
					}
				}
				return getMockData();
			}

			// ç®€å•çš„æ¨¡æ‹Ÿæ•°æ®ï¼Œé˜²æ­¢é¡µé¢ç©ºç™½
			function getMockData() {
				return new Promise(resolve => {
					// æ„é€ ä¸€äº›è™šæ‹Ÿæ•°æ®ç»“æ„å…¼å®¹ p.segments
					// è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¦‚æœæœ¬åœ°æœ‰jsonæ–‡ä»¶æœ€å¥½
					d3.json('data/records.json', function(error, data) {
						if(!error) resolve(data);
						else resolve([]); 
					});
				});
			}
			
			// åŠ›å¯¼å‘å‚æ•°è°ƒæ•´ï¼šæ‰‹ç»˜é£æ ¼é€šå¸¸å…ƒç´ é—´è·å¤§ä¸€ç‚¹å¥½çœ‹
			var simulation = d3.forceSimulation()
				.velocityDecay(0.3) // å¢åŠ é˜»å°¼ï¼ŒåŠ¨å¾—æ…¢ä¸€ç‚¹æ›´å¯çˆ±
				.force("link", d3.forceLink().id(d => d.id).distance(180))
				.force("charge", d3.forceManyBody().strength(-550))
				.force("center", d3.forceCenter(width / 2, height / 2))
				.force("collision", d3.forceCollide().radius(d => getStyle(d.label).radius + 10));
			
			var nodes = [], links = [];
			
			// è·å–æ ·å¼è¾…åŠ©å‡½æ•°
			function getStyle(label) {
				return NODE_STYLES[label] || NODE_STYLES['default'];
			}

			loadGraphData().then(function(graph) {
				const nodeSet = new Set();
				nodes = [];
				links = [];
				
				if (graph && graph.length > 0) {
					for (let item of graph) {
						if (!item.p || !item.p.segments) continue;
						for (let segment of item.p.segments) {
							const startId = identityToString(segment.start.identity);
							const endId = identityToString(segment.end.identity);
							
							if (!nodeSet.has(startId)) {
								nodeSet.add(startId);
								nodes.push({ id: startId, label: segment.start.labels[0], properties: segment.start.properties });
							}
							if (!nodeSet.has(endId)) {
								nodeSet.add(endId);
								nodes.push({ id: endId, label: segment.end.labels[0], properties: segment.end.properties });
							}
							links.push({ source: startId, target: endId, type: segment.relationship.type });
						}
					}
				}
				
				nodes = nodes.filter(node => !LABEL_BLACKLIST.has(node.label));
				const allowedIds = new Set(nodes.map(node => node.id));
				links = links.filter(link => allowedIds.has(link.source) && allowedIds.has(link.target));

				if (graphState.container) {
					graphState.container.selectAll('*').remove();
				}

				const linkLayer = graphState.container.append("g").attr("class", "links");
				const nodeLayer = graphState.container.append("g").attr("class", "nodes");
				const textLayer = graphState.container.append("g").attr("class", "texts");

				const link = linkLayer.selectAll("line").data(links).enter().append("line");

				const node = nodeLayer.selectAll("circle").data(nodes).enter()
					.append("circle")
					.attr("r", d => getStyle(d.label).radius)
					.attr("fill", d => {
						const style = NODE_STYLES[d.label];
						return style ? style.color : getRandomPastelColor(d.properties.name || d.id);
					})
					.call(d3.drag()
						.on("start", dragstarted)
						.on("drag", dragged)
						.on("end", dragended)
					);

				node.append("title").text(d => d.properties.name);

				const text = textLayer.selectAll("text")
					.data(nodes).enter()
					.append("text")
					.text(d => d.properties.name || d.id)
					.attr("font-size", d => {
						const r = getStyle(d.label).radius;
						return Math.max(12, r / 1.8) + "px";
					})
					.attr("dy", "0.35em");

				graphState.nodes = nodes;
				graphState.links = links;
				graphState.nodeSelection = node;
				graphState.linkSelection = link;
				graphState.textSelection = text;

				simulation.nodes(nodes).on("tick", ticked);
				simulation.force("link").links(links);
				graphState.simulation = simulation;
				
				function ticked() {
					link
						.attr("x1", d => d.source.x)
						.attr("y1", d => d.source.y)
						.attr("x2", d => d.target.x)
						.attr("y2", d => d.target.y);
					
					node
						.attr("cx", d => d.x)
						.attr("cy", d => d.y);
					
					text
						.attr("x", d => d.x)
						.attr("y", d => d.y); 
				}
				
				let dragging = false;
				function dragstarted(d) {
					if (!d3.event.active) simulation.alphaTarget(0.3).restart();
					d.fx = d.x;
					d.fy = d.y;
					dragging = true;
				}
				function dragged(d) {
					d.fx = d3.event.x;
					d.fy = d3.event.y;
				}
				function dragended(d) {
					if (!d3.event.active) simulation.alphaTarget(0);
					d.fx = null;
					d.fy = null;
					dragging = false;
				}

				node.on('mouseenter', function(d) {
					if (dragging) return;
					applyHoverState(d);
					showInfoPanel(d);
					notifyParent('nodeSelected', {
						name: d.properties.name || 'æœªçŸ¥',
						color: getStyle(d.label).color,
						properties: d.properties || {}
					});
				});
				
				node.on('mouseleave', function(d) {
					if (dragging) return;
					if (graphState.hoveredNodeId === d.id) {
						clearHoverState();
						hideInfoPanel();
						notifyParent('nodeDeselected', {});
					}
				});

				node.on('click', function(d) {
					d3.event.stopPropagation();
					// æ¸…é™¤ hover çŠ¶æ€ï¼Œç‚¹å‡»æ—¶ä»…ä¿ç•™ç‚¹å‡»æ•ˆæœ
					clearHoverState();
				});

				if (graphState.pendingSearch) {
					runSearch(graphState.pendingSearch);
					graphState.pendingSearch = null;
				}
			});
			
			// -----------------------------
			// 3. çª—å£æ‹–æ‹½é€»è¾‘ (é¢æ¿)
			// -----------------------------
			// ... (ä»£ç å·²åŒ…å«åœ¨ CSS transform ä¸­ï¼Œæ­¤å¤„ä¿ç•™ JS æ‹–æ‹½ä»¥æ”¯æŒå¤§èŒƒå›´ç§»åŠ¨)
		});
	</script>
</body>
</html>